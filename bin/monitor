#!/bin/bash
# monitor output of a command

# quietly exit from keyboard interrupts (CTRL+C)
# disables echo for interrupt signal and restores when script ends
stty -echoctl
trap "stty echoctl" EXIT
trap "exit" INT

command="$*"          # command to run
refresh_interval=10   # refresh screen every 30 iterations (1min)

clear




old_lines=0         # initial line counts
refresh_counter=0   # track refresh count

while true; do
  # save cursor position
  tput sc
  # move cursor to top left
  tput home

  # run the command, redirecting stderr to stdout
  # to ensure we count all visible lines
  output=$($command 2>&1)
  new_lines=$(echo -e "$output" | wc -l)

  # print the output
  OLD_IFS=$IFS
  IFS=$'\n' # set delimiter to newline for the loop
  for line in $output; do
    tput el       # clear to the end of the line
    echo "$line"
  done
  IFS=$OLD_IFS # restore default delimiter

   # if the new output is shorter than the old one, clear the remaining lines
  if [ "$new_lines" -lt "$old_lines" ]; then
    for ((i=new_lines; i<old_lines; i++)); do
      tput el   # clear to the end of the line
      tput cud1 # moves the cursor one line down
    done

    tput home   # move the cursor back to the top
  fi

  # restore cursor position
  tput rc

  # remember line count for the next iteration
  old_lines=$new_lines

  sleep 2

  # clear the screen every $refresh_interval iterations
  ((refresh_counter++))
  if [ $refresh_counter -eq $refresh_interval ]; then
    clear
    refresh_counter=0
  fi
done



