#!/usr/bin/env bash

set -euo pipefail

stderr() {
  echo "$@" >&2
}

run() {
  stderr "$(color -f bright_green '‚ùØ')" "$@"
  "$@"
}

usage() {
  stderr
  stderr "$(color -f bold "git agent")"
  stderr
  stderr "create/reuse a worktree for the current repo and run an agent inside it."
  stderr
  stderr "$(color -f bright_white "USAGE")"
  stderr "  git agent [options] [-- <agent args>‚Ä¶]"
  stderr
  stderr "$(color -f bright_white "OPTIONS")"
  stderr "  -n, --name <name>  Worktree name (overrides $(color -f bright_white \$GIT_AGENT_WORKTREE_NAME))."
  stderr "  --binary <cmd>     Agent command to run (overrides $(color -f bright_white \$GIT_AGENT_BINARY))."
  stderr "  -l, --ls, --list   List all worktrees in this repo."
  stderr "  --shell            Enter an interactive shell in the worktree (default $(color -f bright_white \$SHELL))."
  stderr "                     Note: $(color -f bright_white --shell) is forced off when stdin/stdout are not TTYs."
  stderr "  --no-shell         Never enter a shell (default when not attached to a TTY)."
  stderr "  -R, --reset        Reset the worktree to the current repo HEAD (hard reset + clean)."
  stderr "  -D, --rm, --delete Remove the worktree for $(color -f bright_white --name) and exit."
  stderr "  -h, --help         Show this help."
  stderr
  stderr "$(color -f bright_white "ARGS")"
  stderr "  [agent args]       Passed through to the agent binary (after $(color -f bold --))."
  stderr
  stderr "$(color -f bright_white "ENV")"
  stderr "  GIT_AGENT_BINARY           Agent command to run (default: $(color -f bold codex))"
  stderr "  GIT_AGENT_WORKTREE_NAME    Worktree name (default: $(color -f bold git-agent))"
  stderr "  GIT_AGENT_WORKTREES_ROOT   Root directory for worktrees (default: $(color -f bright_white ~/code/worktrees))"
  stderr
  stderr "$(color -f bright_white "EXAMPLES")"
  stderr "  git agent"
  stderr "  git agent --name a"
  stderr "  git agent --delete --name a"
  stderr "  git agent --binary opencode --name b"
  stderr "  git agent --name a -- --yolo"
  stderr "  git agent --list"
  stderr "  git agent --shell"
  stderr
}

shell_mode="auto"
delete_mode="no"
reset_mode="no"
list_mode="no"
git_agent_binary="${GIT_AGENT_BINARY:-"codex"}"
worktree_name="git-agent"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -l|--ls|--list) list_mode="yes"; shift ;;
    --shell) shell_mode="yes"; shift ;;
    --no-shell) shell_mode="no"; shift ;;
    --binary)
      if [[ $# -lt 2 || -z "${2:-}" ]]; then
        usage
        stderr "missing argument for $(color -f dim --binary)"
        exit 2
      fi
      git_agent_binary="$2"
      shift 2
      ;;
    --binary=*)
      git_agent_binary="${1#--binary=}"
      if [[ -z "$git_agent_binary" ]]; then
        usage
        stderr "missing argument for $(color -f dim --binary)"
        exit 2
      fi
      shift
      ;;
    -n|--name)
      if [[ $# -lt 2 || -z "${2:-}" ]]; then
        usage
        stderr "missing argument for $(color -f dim --name)"
        exit 3
      fi
      worktree_name="$2"
      shift 2
      ;;
    --name=*)
      worktree_name="${1#--name=}"
      if [[ -z "$worktree_name" ]]; then
        usage
        stderr "missing argument for $(color -f dim --name)"
        exit 3
      fi
      shift
      ;;
    -D|--rm|--delete) delete_mode="yes"; shift ;;
    -R|--reset) reset_mode="yes"; shift ;;
    -h|--help|help)
      usage
      exit 0
      ;;
    --) shift; break ;;
    -*)
      usage
      stderr "unknown option: $(color -f dim $1)";
      exit 4
      ;;
    *) break ;;
  esac
done

# bash test for "am I running interactively in a terminal?"
# -t FD is true if file descriptor FD points at a TTY (terminal)
# 0 = stdin, 1 = stdout, so true when stdin and stdout are a TTY
# e.g. `echo $(git agent)` will trip this safeguard
if [[ ! -t 0 || ! -t 1 ]]; then
  shell_mode="no"
fi

worktrees_root="${GIT_AGENT_WORKTREES_ROOT:-"$HOME/code/worktrees"}"

# stderr "shell_mode=$shell_mode"
# stderr "delete_mode=$delete_mode"
# stderr "reset_mode=$reset_mode"
# stderr "git_agent_binary=$git_agent_binary"
# stderr "worktree_name=$worktree_name"
# stderr "agent_args=$*"
# exit 99

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  usage
  exit 5
fi


repo_root="$(git rev-parse --show-toplevel)"
repo_origin="$(git -C "$repo_root" remote get-url origin 2>/dev/null || true)"
repo_origin="${repo_origin%.git}"

if [[ "$list_mode" == "yes" ]]; then
  run git -C "$repo_root" worktree list --porcelain
  exit 0
fi

repo_path=""
case "$repo_origin" in
  git@github.com:*)          repo_path="${repo_origin#git@github.com:}" ;;
  https://github.com/*)      repo_path="${repo_origin#https://github.com/}" ;;
  ssh://git@github.com/*)    repo_path="${repo_origin#ssh://git@github.com/}" ;;
esac

if [[ -z "$repo_path" ]]; then
  repo_path="$(basename "$repo_root")"
  stderr "‚ö†Ô∏è $(color -f yellow WARN): fallback to repository directory name ($(color -f dim "$repo_path"))"
fi

head_commit="$(git -C "$repo_root" rev-parse HEAD)"
worktree_path="$worktrees_root/$repo_path/$worktree_name"

# if dir exists, ensure it is an actual worktree
if [[ -d "$worktree_path" ]]; then
  if ! git -C "$worktree_path" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    stderr "üö® $(color -f red ERROR): worktree path exists but is not a git worktree ($(color -f dim "$worktree_path"))"
    exit 4
  fi
fi

if [[ "$delete_mode" == "yes" ]]; then
  if [[ ! -d "$worktree_path" ]]; then
    stderr "‚úÖ worktree does not exist ($(color -f dim "$worktree_path"))"
  else
    stderr "‚ùå delete worktree ($(color -f dim "$worktree_path"))"
    run git -C "$repo_root" worktree remove --force "$worktree_path"
  fi

  exit 0
fi

maybe_prepare_worktree() {
  # create worktree if it does not exist
  if [[ ! -d "$worktree_path" ]]; then
    stderr "creating new worktree ($(color -f dim "$worktree_path"))"
    reset_mode="no"
    run git -C "$repo_root" worktree add --detach "$worktree_path" "$head_commit"
    return
  fi

  stderr "reuse existing worktree ($(color -f dim "$worktree_path"))"

  # proceed to reset when explicitly requested
  [[ "$reset_mode" == "yes" ]] && return

  # already in sync, no need to reset
  current_commit="$(git -C "$worktree_path" rev-parse HEAD)"
  if [[ "$current_commit" == "$head_commit" ]]; then
    return
  fi

  # proceed to reset to keep clean worktree in sync
  if [[ -z "$(git -C "$worktree_path" status --porcelain)" ]]; then
    reset_mode="yes"
    return
  fi

  # warn when worktree has local changes and is not updated
  stderr "‚ö†Ô∏è $(color -f yellow WARN): worktree has local changes; leaving at $(color -f dim "$current_commit")"
  stderr "    use $(color -f cyan "--reset") to force reset to $(color -f dim "$head_commit")"
}

maybe_prepare_worktree

if [[ "$reset_mode" == "yes" ]]; then
  stderr "üîÑ reset worktree to repo HEAD ($(color -f dim "$head_commit"))"
  run git -C "$worktree_path" checkout --detach --force "$head_commit"
  run git -C "$worktree_path" clean -fd
fi

enter_worktree_shell() {
  stderr "starting shell in worktree"
  run cd "$worktree_path"
  shell_cmd=("${SHELL:-bash}" -i)
  stderr "$(color -f bright_green '‚ùØ')" "${shell_cmd[@]}"
  stderr "üí° run $(color -f bold cyan exit) to leave worktree"
  exec "${shell_cmd[@]}"
}

if [[ "$shell_mode" == "yes" ]]; then
  enter_worktree_shell
fi

if ! command -v "$git_agent_binary" >/dev/null 2>&1; then
  stderr "‚ö†Ô∏è $(color -f yellow WARN): missing agent binary ($(color -f dim "$git_agent_binary"))"
else
  stderr "starting $(color -f cyan "$git_agent_binary") ($(color -f dim "$worktree_path"))"
  run cd "$worktree_path"
  run "$git_agent_binary" "$@"
  stderr "agent exited"

  if [[ "$shell_mode" != "no" ]]; then
    enter_worktree_shell
  fi
fi

