#!/usr/bin/env bash

set -euo pipefail

stderr() {
  echo "$@" >&2
}

run() {
  stderr $(color -f bright_green '‚ùØ') "$@"
   "$@"
}

usage() {
  stderr "usage: git agent <name>"
  exit 2
}

shell_mode="auto"
while [[ $# -gt 0 ]]; do
  case "$1" in
    --shell) shell_mode="yes"; shift ;;
    --no-shell) shell_mode="no"; shift ;;
    -h|--help) usage ;;
    --) shift; break ;;
    -*) stderr "unknown option: $1"; usage ;;
    *) break ;;
  esac
done

# bash test for "am I running interactively in a terminal?"
# -t FD is true if file descriptor FD points at a TTY (terminal)
# 0 = stdin, 1 = stdout, so true when stdin and stdout are a TTY
# e.g. `echo $(git agent --shell opencode-a)` will trip this safeguard
if [[ ! -t 0 || ! -t 1 ]]; then
  shell_mode="no"
fi

worktree_name="${1:-}"

if [[ -z "$worktree_name" ]]; then
  usage
fi

# shift out worktree name so `$@` correct capturing agent binary args
shift

worktrees_root="${GIT_AGENT_WORKTREES_ROOT:-"$HOME/code/worktrees"}"
git_agent_binary="${GIT_AGENT_BINARY:-"opencode"}"

# stderr "shell_mode=$shell_mode"
# stderr "agent_args=$*"
# exit 99

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  usage
fi

repo_root="$(git rev-parse --show-toplevel)"
repo_origin="$(git -C "$repo_root" remote get-url origin 2>/dev/null || true)"
repo_origin="${repo_origin%.git}"

repo_path=""
case "$repo_origin" in
  git@github.com:*)          repo_path="${repo_origin#git@github.com:}" ;;
  https://github.com/*)      repo_path="${repo_origin#https://github.com/}" ;;
  ssh://git@github.com/*)    repo_path="${repo_origin#ssh://git@github.com/}" ;;
esac

if [[ -z "$repo_path" ]]; then
  repo_path="$(basename $repo_root)"
  stderr "‚ö†Ô∏è $(color -f yellow WARN): fallback to repository directory name ($(color -f dim $repo_path))"
fi

# ensure branch exists
head_commit="$(git -C "$repo_root" rev-parse HEAD)"
if ! git -C "$repo_root" show-ref --verify --quiet "refs/heads/$worktree_name"; then
  stderr "create branch ($worktree_name)"
  run git -C "$repo_root" branch -f "$worktree_name" "$head_commit"
else
  stderr "reuse existing branch ($(color -f dim $worktree_name))"
fi

worktree_path="$worktrees_root/$repo_path/$worktree_name"

# create worktree if it does not exist
if [[ ! -d "$worktree_path" ]]; then
  run git -C "$repo_root" worktree add "$worktree_path" "$worktree_name"
else
  stderr "reuse existing worktree ($(color -f dim $worktree_path))"
fi

# ensure dir is an actual worktree
if ! git -C "$worktree_path" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  stderr "üö® $(color -f red ERROR): worktree path exists but is not a git worktree ($(color -f dim $worktree_path))"
  exit 3
fi

if ! command -v "$git_agent_binary" >/dev/null 2>&1; then
  stderr "‚ö†Ô∏è $(color -f yellow WARN): missing agent binary ($(color -f dim $git_agent_binary))"
else
  stderr "starting $git_agent_binary ($(color -f dim $worktree_path))"
  run cd "$worktree_path"
  run "$git_agent_binary" "$@"
fi

if [[ "$shell_mode" == "yes" ]]; then
  exec "${SHELL:-bash}"
fi
